#include <iostream>  
#include <vector>   
#include <cstdlib>   
#include <ctime>    
#include <cmath>    
using namespace std;

// Hàm tạo số ngẫu nhiên theo phân phối chuẩn - lấy từ phương pháp Box-Muller -> thuật toán chuẩn
double random(double mi, double sigma) {
    static bool call = false;
    static double spare;

    if (call) {
        call = false;
        return mi + sigma * spare;
    }

    call = true;
    double x, y, A;
    do {
        x = ((double)rand() / RAND_MAX) * 2.0 - 1.0;
        y = ((double)rand() / RAND_MAX) * 2.0 - 1.0;
        A = x * x + y * y;
    } while (A >= 1.0 || A == 0.0);
    
    A = sqrt(-2.0 * log(A) / A);
    spare = y * A;
    return mi + sigma * x * A;
}

class BanditTestbed {
public:
    int k;                      
    vector<double> true_values; 

    BanditTestbed(int num_actions) {
        k = num_actions;
        true_values.resize(k);
        for (int i = 0; i < k; ++i) {
            true_values[i] = random(0.0, 1.0); // Gán giá trị thật ngẫu nhiên
        }
    }

    // Agent đưa vào một hành động, môi trường trả về phần thưởng
    double get_reward(int action) {
        // Phần thưởng ngẫu nhiên xoay quanh giá trị thật của hành động đó
        return random(true_values[action], 1.0);
    }
};

// --- HÀM CHẠY THÍ NGHIỆM ---
vector<double> run_epsilon_greedy_experiment(int k, int num_steps, int num_runs, double epsilon) {
    vector<double> average_rewards(num_steps, 0.0);

    // Vòng lặp ngoài: Lặp lại toàn bộ thí nghiệm num_runs lần
    for (int run = 0; run < num_runs; ++run) {
        BanditTestbed testbed(k); // Tạo môi trường mới
        vector<double> Q(k, 0.0);  // Reset "bộ não" agent
        vector<double> N(k, 0.0);

        // Vòng lặp trong: Một "cuộc đời" của agent
        for (int step = 0; step < num_steps; ++step) {
            int action_to_take;

            // --- LOGIC CỐT LÕI CỦA EPSILON-GREEDY ---
            if (((double)rand() / RAND_MAX) < epsilon) {
                // Thăm dò: Chọn hành động ngẫu nhiên
                action_to_take = rand() % k;
            } else {
                // Khai thác: Chọn hành động có điểm Q cao nhất
                action_to_take = 0;
                for (int i = 1; i < k; ++i) {
                    if (Q[i] > Q[action_to_take]) {
                        action_to_take = i;
                    }
                }
            }
            
            // Tương tác với môi trường và học hỏi
            double reward = testbed.get_reward(action_to_take);
            N[action_to_take]++;
            Q[action_to_take] += (1.0 / N[action_to_take]) * (reward - Q[action_to_take]);
            
            // Cộng dồn kết quả để tính trung bình sau này
            average_rewards[step] += reward;
        }
    }

    // Tính trung bình cuối cùng sau khi đã chạy hết num_runs
    for (int i = 0; i < num_steps; ++i) {
        average_rewards[i] /= num_runs;
    }
    
    return average_rewards;
}

// --- HÀM ĐIỀU KHIỂN CHÍNH ---
int main() {
    // Gieo mầm ngẫu nhiên chỉ một lần
    srand(time(0)); 

    // Các tham số cố định cho thí nghiệm
    const int K = 10;
    const int NUM_STEPS = 1000;
    const int NUM_RUNS = 2000;

    // Vòng lặp tương tác với người dùng
    while (true) {
        double epsilon_to_test;
        cout << "\n>>> Nhap gia tri epsilon de thu nghiem (hoac nhap so am de thoat): ";
        cin >> epsilon_to_test;

        // Điều kiện để thoát chương trình
        if (epsilon_to_test < 0) {
            cout << "Thoat chuong trinh." << endl;
            break; 
        }

        // Chạy thí nghiệm với epsilon vừa nhập
        cout << "Dang chay thi nghiem voi epsilon = " << epsilon_to_test << "..." << endl;
        vector<double> results = run_epsilon_greedy_experiment(K, NUM_STEPS, NUM_RUNS, epsilon_to_test);

        // In kết quả của thí nghiệm này ra màn hình
        cout << "--- Ket qua cho Epsilon = " << epsilon_to_test << " ---\n";
        cout << "Step,AverageReward\n";
        for (int i = 0; i < NUM_STEPS; ++i) {
            cout << i + 1 << "," << results[i] << "\n";
        }
    }

    return 0;
}
