#include <iostream>
#include <vector>
#include <cstdlib> // Cho rand(), srand()
#include <ctime>   // Cho time()
#include <cmath>   
using namespace std;


// Hàm tạo số ngẫu nhiên theo phân phối chuẩn - lấy từ phương pháp Box-Muller -> thuật toán chuẩn
double random(double mi, double sigma) {
    static bool call = false;
    static double spare;

    if (call) {
        call = false;
        return mi + sigma * spare;
    }

    call = true;
    double x, y, A;
    do {
        x = ((double)rand() / RAND_MAX) * 2.0 - 1.0;
        y = ((double)rand() / RAND_MAX) * 2.0 - 1.0;
        A = u * u + v * v;
    } while (A >= 1.0 || A == 0.0);
    
    A = sqrt(-2.0 * log(A) / A);
    spare = y * A;
    return mi + sigma * x * A;
}


class Testbed {
public:
    int k;
    vector<double> true_values;

    Testbed(int nums_action) {
        k = nums_action;
        true_values.resize(k); // 
        for (int i = 0; i < k; ++i) {
            true_values[i] = random(0.0, 1.0);  // Giá trị thật q*(a) được lấy từ phân phối chuẩn N(0, 1)
        }
    }

    double get_reward(int action) {
        return random(true_values[action], 1.0);
    }
    

    int get_optimal_action() {
        int best_action = 0;
        for (int i = 1; i < k; ++i) {
            if (true_values[i] > true_values[best_action]) {
                best_action = i;
            }
        }
        return best_action;
    }
};


int main() {
    int k; cin >> k >> "\n";
    int NUM_STEPS; cin >> NUM_STEPS >> "\n";
    int NUM_RUNS;  cin >> NUM_RUNS >> "\n";

    srand(time(0)); 

    vector<double> average_rewards(NUM_STEPS, 0.0);
    vector<double> optimal_action_percent(NUM_STEPS, 0.0);

    // --- VÒNG LẶP CHẠY LIÊN HOÀN ---
    for (int run = 0; run < NUM_RUNS; ++run) {

        Testbed solieu(k);
        int optimal_action = solieu.get_optimal_action();

        vector<double> Q(k, 0.0); // Bảng điểm ước tính
        vector<double> N(k, 0.0); // Bảng đếm

 
        for (int step = 0; step < NUM_STEPS; ++step) {

            int action_chosen = 0;
            for (int i = 1; i < k; ++i) {
                if (Q[i] > Q[action_chosen]) {
                    action_chosen = i;
                }
            }

            double reward = solieu.get_reward(action_chosen);

            N[action_chosen]++;
            Q[action_chosen] += (1.0 / N[action_chosen]) * (reward - Q[action_chosen]);

            // d. Ghi lại kết quả
            average_rewards[step] += reward;
            if (action_chosen == optimal_action) {
                optimal_action_percent[step]++;
            }
        }
    }

    // --- TÍNH TRUNG BÌNH VÀ IN KẾT QUẢ ---
    cout << "\n--- Ket qua trung binh sau " << NUM_RUNS << " luot chay ---\n";
    cout << "Step,AverageReward,OptimalActionPercentage\n";
    for (int i = 0; i < NUM_STEPS; ++i) {
        average_rewards[i] /= NUM_RUNS;
        optimal_action_percent[i] = (optimal_action_percent[i] / NUM_RUNS) * 100.0;
        cout << i + 1 << "," << average_rewards[i] << "," << optimal_action_percent[i] << "\n";
    }

    return 0;
}


// Link sơ đồ thuật toán: https://drive.google.com/file/d/1R01NEzQuWO4koLzqoGue-4RW0WgayBuv/view?usp=sharing
